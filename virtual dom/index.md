### DOM 操作的缺陷

1. 操作 DOM 会引起重排
2. 强制同步布局和布局抖动
3. 复杂单页应用，操作非常昂贵

### 主要思想：

模拟 DOM 的树状结构，在内存中创建保存映射 DOM 信息的节点数据，在由于交互等因素需要视图更新时，先通过对节点数据进行 diff 后得到差异结果后，再一次性对 DOM 进行批量更新操作，这就好比在内存中创建了一个平行世界，浏览器中 DOM 树的每一个节点与属性数据都在这个平行世界中存在着另一个版本的虚拟 DOM 树，所有复杂曲折的更新逻辑都在平行世界中的 VirtualDOM 处理完成，只将最终的更新结果发送给浏览器中的 DOM 树执行，这样就避免了冗余琐碎的 DOM 树操作负担，进而有效提高了性能。

### diff 算法：

如何识别并保存新旧节点数据结构之间差异的方法

### diff 主要策略（双端比较算法比较新旧树的同层级每个元素）：

- 按 tree 层级 diff(level by level)：数据结构是以 DOM 渲染为目标的模拟树状层级结构的节点数据，而在 WebUI 中很少出现 DOM 的层级结构因为交互而产生更新，因此 VirtualDOM 的 diff 策略是在新旧节点树之间按层级进行 diff 得到差异，而非传统的按深度遍历搜索，这种通过大胆假设得到的改进方案，不仅符合实际场景的需要，而且大幅降低了算法实现复杂度，从 O(n^3)提升至 O(n)。
- 按类型进行 diff：无论 VirtualDOM 中的节点数据对应的是一个原生的 DOM 节点还是 vue 或者 react 中的一个组件，不同类型的节点所具有的子树节点之间结构往往差异明显，因此对不同类型的节点的子树进行 diff 的投入成本与产出比将会很高昂，为了提升 diff 效率，VirtualDOM 只对相同类型的同一个节点进行 diff，当新旧节点发生了类型的改变时，则并不进行子树的比较，直接创建新类型的 VirtualDOM，替换旧节点。
- 列表 diff：当被 diff 节点处于同一层级时，通过三种节点操作新旧节点进行更新：插入，移动和删除，同时提供给用户设置 key 属性的方式调整 diff 更新中默认的排序方式，在没有 key 值的列表 diff 中，只能通过按顺序进行每个元素的对比，更新，插入与删除，在数据量较大的情况下，diff 效率低下，如果能够基于设置 key 标识尽心 diff，就能够快速识别新旧列表之间的变化内容，提升 diff 效率。

### React Fiber 架构（让自己的 Reconcilation（协调）过程变成可被中断）fiber 意为协程，让出进程

#### 优点

- 老的算法是会递归比对 VirtualDOM 树，找出需要变动的节点，然后同步更新它们, 一气呵成，新的会'适时'地让出 CPU 执行权，可以让浏览器及时地响应用户的交互
- 与其一次性操作大量 DOM 节点相比, 分批延时对 DOM 进行操作，可以得到更好的用户体验
- 给浏览器一点喘息的机会，他会对代码进行编译优化（JIT）及进行热代码优化，或者对 reflow 进行修正

### vue 优化每个任务，让它有多快就多快。挤压 CPU 运算量

### 目前速度最快的时 inferno.js （react like 库）

- 所有虚拟 DOM 都统一数据结构，创建时就可以初始化好数据结构，而 react 需要运行时判断（是一个 class 还是一个 function，数据结构不太一样）
- 位运算来进行逻辑判断
- vdom 比较
  - A: [a b c d]
  - B: [d a b c]
  - react 会把 a,b,c 依次挪到后面，三次
  - inferno 会找到最长递增子序列，直接把 abc 挪到后面，一次完成
- 编译时做了很多优化工作，通过 babel 提前处理 props，而 react，vue 都是等到运行时在处理
