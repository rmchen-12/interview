## 导航流程
- 用戶输入 地址栏会判断输入的关键字是搜索内容，还是请求的URL
- 进入导航流程，tab页出现loading图表，但是页面没改变
 URL请求过程 浏览器进程会通过进程间通信(IPC)把URL请求发送至网络进程，网络进程接收到URL请求后，会在这里发起真正的URL请求流程
 - 构建请求 `GET /index.html HTTP1.1`
 - 查找缓存 `200 (from disk cache)或是200 OK (from memory cache)，存哪里有内存使用率决定` 真正发起请求前，先找浏览器缓存，没有再网络请求
 - 准备IP地址和端口 DNS解析域名，端口默认80，如果是https还要建立TLS连接
 - 等待TCP队列
 - 建立TCP连接
 - 发送HTTP请求
   - 返回的状态码是301(永久重定向)或者302(临时重定向)，那么 说明服务器需要浏览器重定向到其他URL,一切又重头开始了
   - 304 使用本地缓存
   - 200的话继续处理
     - 根据Content-Type值来，是text/html就准备渲染进程，否则按对应的进程来处理
 - 准备渲染阶段
   - 通常情况下，打开新的⻚面都会使用单独的渲染进程
   - 如果从A⻚面打开B⻚面，且A和B都属于同一站点的话，那么B⻚面复用A⻚面的渲染进程;如果是其他情况，浏览器进程则会为B创建一个新的渲染进程
 - 提交文档，文档就是响应体数据
   - 浏览器进程发出提交文档消息，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”，HTML解析器(HTMLParser)是网络进程加载了多少数据，HTML解析器便解析多少数据
   - 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程
   - 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的URL、前 进后退的历史状态，并更新Web⻚面
- 导航流程完成，开始渲染流程

## 渲染流程：
- 构建DOM树，
  1. 自上而下，主要dom放前面，优先渲染
- 样式计算
  - 先转化styleSheets，
    1. 首屏关键样式内联(HtmlCriticalWebpackPlugin，用处不大，mini也可以内联样式)，不用href去下载，其他不出现在首屏的会加a标签`rel="preload" as="style"`来预下载
    2. cssTreeShaking（PurifyCSS插件），可以根据html的节点属性和css的各个选择器匹配，类似babelAST的处理，没用到的就摇掉
    3. 按需加载（mini-css-extract-plugin），或者不拆分出来，加载js的时候再去动态创建css标签
  - 转化样式属性值到标准化值，如em,blue等转化为px,rgb(0,0,255)，
    1. 尽量用标准化值来书写
  - 计算出DOM树中每个节点的具体样式
    - 继承样式
    - 层叠样式
- 布局阶段，根据DOM树和CSSOM生成布局树
- 分层，(relative,absolute且z-index不为auto，opacity小于1，fixed或sticky，transform,filter不为none,will-change或者需要裁减的元素)
  1. 给动画部分加will-change等属性，提升为单独一层，GPU加速
  2. 写动画尽量用css3写，如果一定要用js的话用requestAnimateFrame
- 图层绘制，输出绘制指令列表
- 栅格化(raster)操作，绘制列表提交(commit)给合成线程，将图块转换为位图
  - 分块，视口附近的图块来优先生成位图 
  - 栅格化线程池将图块转换为位图，通常这个过程由GPU加速完成
- 合成和显示，栅格化完成后合成线程通知浏览器进程显示页面


重排：改变元素的宽度、高度等几何属性，浏览器会重新布局，重走整个流程
重绘：js更改某些元素的背景颜色，跳过布局阶段，比重排好点
直接合成阶段：使用transform实现动画，直接跳过布局分层绘制阶段，到非主线程的部分，相对于重绘和重排，合成能大大提升绘制效率。

### 减少重排和重绘的方法(批量操作css，批量操作js)：
1. 使用 class 操作样式，而不是频繁操作 style
2. 避免使用 table 布局
3. 批量dom 操作，例如 createDocumentFragment，display：none，或者使用框架，例如 React 
4. Debounce window resize 事件
4. 对 dom 属性的读写要分离
5. will-change: transform 做优化

## 影响⻚面展示的因素以及优化策略
### 第一阶段，导航阶段，针对服务器和网络优化
谷歌浏览器控制台的network图表
- Queuing，等待阶段
  - 关键资源有限，非关键资源就会等待
  - 每个域名最多6个TCP，超过了就要等待
    1. 域名分片，cdn加载
    2. 升级到http2
  - 网络进程在为数据分配磁盘空间时，新的请求也要等待
- Initial connection/SSL阶段，建立tcp连接的时间，如果有https的话，还有SSL握手的时间
- Request sent阶段，和服务器建立好连接之后，网络进程会准备请求数据，并将其发送给网络，这个只需要将缓存区数据发出去即可，通常不到1ms
- waiting（TTFB）第一字节时间，等待接收服务器第一个字节的数据
  1. 服务器生成⻚面数据的时间过久，提高服务器的处理速度
  2. 网络的原因，增加各种缓存技术，微信里靠设置请求头，app里还可以设置离线包的方式拦截请求，返回离线包
  3. 发送请求头时带上了多余的用戶信息，比如一些不必要的Cookie信息，服务器接收到这些Cookie信息之后可能需要对每一项都做处理，这样就加大了服务器的处理时⻓。
- Content Download 收到第一字节后就陆陆续续接收全部响应数据
  1. 可能是字节数太多，webpack开启压缩，gzip

### 第二阶段，解析白屏，首屏渲染，缩短白屏时间
通常情况下的瓶颈主要体现在下载CSS文件、下载JavaScript文件和执行JavaScript，减少关键资源大小，数量
- js
  1. js开启treeShaking
  2. 按需加载js, import()方法
  3. js加async,defer，升级到webpack4使用新的代码拆分方式(拆分出vendor和common)
  4. 首屏对没出现在视图内的实现按需加载，结合`IntersectionObserver`控制一个变量，出现时再去import()
  5. vw单位适配，去掉rem适配代码
- css 
  1. css开启treeShaking 
  2. css，mini-css-extract-plugin(按需加载，不重复编译，只针对css，更容易使用)，媒体查询等
  3. 首屏关键样式内联(HtmlCriticalWebpackPlugin)，不用href去下载，js视情况内联，减少请求
- babel
  1. 用最新的babel7，preset-env配置出`useBuiltIns: entry`，减少polyfill大小 
  2. 打包出es next代码和es5两套代码，根据<script type="module" /><script nomodule />区分
- 其他 
  1. Caching(service workers + sw-toolbox)
  2. 本地缓存包，拦截请求拿本地离线包
  3. preload(本页提前加载)和prefetch(下一页提前加载)，对于首屏可以加preload，我看谷歌原理里说默认就会预加载js,css？
  4. SSR渲染
  5. div里先渲染一层loading的dom，基本秒开，htmlWebpackPlugin里加参数指向特定文件夹
   
### 第三阶段，交互阶段，优化帧渲染速度
1. 减少JavaScript脚本执行时间，不能让js一次执行霸占太久主线程
   - 一种是将一次执行的函数分解为多个任务，使得每次的执行时间不要过久，比如创建10000个列表。
   - 采用Web Workers，耗时的计算操作放进去，这里还有IPC通信的损耗，时间需要权衡
2. 避免强制同步布局，JavaScript强制将计算样式和布局操作提前到了当前的任务中
   - 方法中修改了dom，同时在后面紧跟着获取dom宽高等属性，为了拿到这个属性，会把样式计算和布局也提前到这次任务中，堵塞进程
3. 避免布局抖动，重复强制同步布局
   - 像for循环里，应该避免在修改dom后又去读取dom属性
4. 合理利用CSS合成动画
   - css动画是可以准确知道屏幕刷新率的，而且可以利用will-change属性来将动画单独提升为一层，不占用主线程
   - js的话用requestAnimateCallback，刷新率也是准确的，requestIdleCallback，在每一帧空闲时执行回调
5. 避免频繁的垃圾回收，在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略    
   - 尽可能优化储存结构，尽可能避免小颗粒对象的产生 
6. 图层是否合理，过多的图层会导致更复杂的光栅化过程
   - 包括深度和数量，一般来说深度在 10 以内，数量在 100 以内是比较合理的值
   - 精简DOM结构
7. 减少重排和重绘

### 不能让js一次执行霸占太久主线程的好处
1. JS进程与渲染进程互斥，堵塞主进程，会导致渲染进程堵塞，导致页面卡顿
2. 分割任务后可以充分利用JIT即时编译技术，对于多次用到的热点代码就可以转为机器码，提升性能
3. 空闲时间还可以穿插垃圾回收，降低内存使用