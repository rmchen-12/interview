### OSI 模型

| 层级 |    名称    |                                                                                                例子 |
| :--- | :--------: | --------------------------------------------------------------------------------------------------: |
| 7    |   应用层   |                 包装数据(http,dns,ftp 文件传输协议,pop3 接受邮件协议，smtp 发送邮件协议，webSocket) |
| 6    |   表示层   |                                                                 SSL/TSL(加密、转换翻译、压缩解压缩) |
| 5    |   会话层   | 为创建、管理和终止会话提供必要的方法(api)，比如 socket,负责管理和确定传输模式(单向，半双工，全双工) |
| 4    |   传输层   |                                                                   端对端，主机对主机的传输(TCP/UDP) |
| 3    |   网络层   |                                                                      从一个设备发送到另一个设备(IP) |
| 2    | 数据链路层 |                       把数据发送到本地网络中去(局域网技术，如以太网，WIFI)，通过 MAC 地址来准确寻址 |
| 1    |   物理层   |                                                          硬件，编码和信号，负责信号的实际发送和接收 |

### TCP/IP 模型

| 层级 |    名称    |   例子 |
| :--- | :--------: | -----: |
| 4    |   应用层   |        |
| 3    |   传输层   | TCP/IP |
| 2    |  互联网层  |        |
| 1    | 网络接口层 |        |

### Socket

实际上是对 TCP/IP 协议的封装，本身并不是协议，而是一个调用接口（API），它工作在 OSI 模型会话层，是为了方便大家直接使用更底层协议（一般是 TCP 或 UDP）而存在的一个抽象层

### webSocket

而 WebSocket 是一个完整的应用层协议，它必须依赖 Http 协议进行`一次握手`，握手成功后，数据就直接从 TCP 通道`传输`，与 Http 无关了
Http 是`短连接`，就是在每次请求完成后就把 TCP 连接关了
WebSocket 是`长连接`，不主动关闭，由代码控制关闭

1. 先 http 握手建立连接，调用 WebSocket 时会自动请求

```
 // 请求
 GET /chat HTTP/1.1   //必需。
 Host: server.example.com  // 必需。WebSocket服务器主机名
 Upgrade: websocket // 必需。并且值为" websocket"。有个空格
 Connection: Upgrade // 必需。并且值为" Upgrade"。有个空格
 Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== // 必需。其值采用base64编码的随机16字节长的字符序列，提供基本的防护，比如恶意的连接，或者无意的连接
 Origin: http://example.com //浏览器必填。头域（RFC6454）用于保护WebSocket服务器不被未授权的运行在浏览器的脚本跨源使用WebSocket API。
 Sec-WebSocket-Protocol: chat, superchat //选填。可用选项有子协议选择器。
 Sec-WebSocket-Version: 13 //必需。版本。

Base64(SHA-1(dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11))

 // 响应
 HTTP/1.1 101 Switching Protocols   //必需。响应头。状态码为101。任何非101的响应都为握手未完成。但是HTTP语义是存在的。
 Upgrade: websocket  // 必需。升级类型。
 Connection: Upgrade //必需。本次连接类型为升级。
 Sec-WebSocket-Accept:s3pPLMBiTxaQ9kYGzzhZRbK+xOo=  //必需。表明服务器是否愿意接受连接。如果接受，值就必须是通过上面算法得到的值。
```

2. 数据传输，以数据帧的形式传输

#### 数据帧

```
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-------+-+-------------+-------------------------------+
 |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
 |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
 |N|V|V|V|       |S|             |   (if payload len==126/127)   |
 | |1|2|3|       |K|             |                               |
 +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
 |     Extended payload length continued, if payload len == 127  |
 + - - - - - - - - - - - - - - - +-------------------------------+
 |                               |Masking-key, if MASK set to 1  |
 +-------------------------------+-------------------------------+
 | Masking-key (continued)       |          Payload Data         |
 +-------------------------------- - - - - - - - - - - - - - - - +
 :                     Payload Data continued ...                :
 + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
 |                     Payload Data continued ...                |
 +---------------------------------------------------------------+
```

- FIN 1:最后一个分片 0：不是最后一个分片
- RSV 默认 0
- opcode
  - 0 说明用了数据分片
  - 1 文本帧
  - 2 二进制帧
  - 3-7 保留
  - 8 连接断开
  - 9 ping 操作
  - A pong 操作
  - B-F 保留
- Mask 1：使用掩码处理 payload
- Payload length 数据载荷的长度
- Masking-key (0 或者 4 个字节) 上面 Mask 为 1 时，这里有客户端挑选出来的 32 位的随机数，作用是代理缓存污染攻击
- Payload data 载荷数据：包括了扩展数据、应用数据

#### 数据传递

根据数据帧来传递

#### 连接保持+心跳

定时发送 ping pong 来保持连接

### http1.1 的改进

1. 每进行一次通信，就要建立一条连接，所以增加了持久连接
2. 提供虚拟主机的⽀持，通过 host 字段来区分
3. 对动态⽣成的内容提供了完美⽀持, Chunk transfer 机制，把一个数据切成若干个块，每个块带一个长度，最后用一个长度为 0 的块来代表结束
4. 客⼾端 Cookie、安全机制

### http1.1 问题，对带宽利用不理想

1. TCP 的慢启动： 慢启动是 TCP 为了减少网络拥塞的一种策略，我们是没有办法改变的
2. 同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽
3. HTTP/1.1 队头阻塞的问题： 虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求

### http2

1. 一个域名只使用一个 TCP ⻓连接来传输数据 (同时解决慢启动和竞争宽带的问题)
2. 增加二进制分帧层，请求响应被转换为一个个带有请求 ID 编号的帧，再根据 ID 进行拼接 (解决请求队列的队头阻塞的问题)
3. 可以设置请求的优先级
4. 服务器推送(请求 HTML 的时候附带将关键 css js 一起推给浏览器)
5. 头部压缩

### http2 头部压缩方法

> 第二次的请求头部之所以非常小，是因为大部分键值对只占用了一个字节。尤其是 UserAgent、Cookie 这样的头部，首次请求中需要占用很多字节，后续请求中都只需要一个字节。

- 维护一份相同的静态字典（Static Table），包含常见的头部名称，以及特别常见的头部名称与值的组合；不存在的键值对在首次请求后就可以添加到动态字典里下次就可以一个字节拿到
- 维护一份相同的动态字典（Dynamic Table），可以动态地添加内容；
- 支持基于静态哈夫曼码表的哈夫曼编码（Huffman Coding）；

### http2 的问题

1. tcp 请求的队头堵塞问题，单个数据包丢失导致 tcp 传输上的堵塞，http2 用了单条管道，问题更严重，会堵塞所有请求
2. tcp 请求需要三次握手(1.5 个 rtt)，启动很慢

### http3 (使用 udp 来实现) QUIC 协议

1. 实现了类似 TCP 的流量控制、传输可靠性的功能
2. 集成了 TLS 加密功能
3. 实现了 HTTP/2 中的多路复用功能，同一物理连接上可以有多个独立的逻辑数据流，解决队头堵塞问题
4. 实现了快速握手功能

问题：

1. 设备僵化
2. 系统内核优化不如 tcp，丢包率高
3. 浏览器支持差
