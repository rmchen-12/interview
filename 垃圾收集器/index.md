### 栈
ESP指针控制执行上下文，函数调用完毕后指针下移，上面这块就可以被新的执行上下文覆盖，完成回收操作

### 堆
代际假说
- 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问(新生代区域-副垃圾回收器，1-8M)
- 不死的对象，会活得更久(老生代区域-主垃圾回收器)

总流程
1. 标记空间中活动对象和非活动对象
2. 回收非活动对象所占据的内存
3. 做内存整理(一般是老生代，新生代不会产生)，频繁回收后会出现大量不连续的空间(内存碎片)

- 副垃圾回收器回收新生代区域(Scavenge算法)
1. 分为两个部分 对象区域和空闲区域 ，
2. 新加入的对象放到对象区域，快被写满时就执行一次垃圾清理
3. 清理时先`标记`对象,然后把活动对象`复制`到空闲区域,同时`有序`的排起来(相当于内存整理)
4. 之后`翻转`对象区域和空闲区域,就完成了一次
5. 复制耗时操作,为了效率,新生区的空间设的都不大
6. `对象晋升`策略 ,经过两次垃圾回收依然还存活的对象，会被移动到老生区中

- 主垃圾回收器回收老生代区域
1. 对象来自新生代区域,或者本身就比较大,那直接放进来
2. `标记-清除`算法进行垃圾回收
   1. 标记 从某个执行上下文开始遍历,看堆内存中有没有对应内存引用,有的就标记为活动对象,没有引用的就标记为垃圾对象
   2. 清除 将垃圾对象清除掉
3. `标记-整理`算法,因为清除后会出现大量不连续内存
   1. 将活动对象往一端挪动,然后直接清理掉端边界以外的内存
4. 老生代里的都是大数据,标记很耗时,有`全停顿`的问题
   1. `增量标记` 可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短， 可以穿插在其他的JavaScript任务中间执行